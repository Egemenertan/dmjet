import { useNavigation, useRoute } from '@react-navigation/native'
import { StackNavigationProp } from '@react-navigation/stack'
import * as Location from 'expo-location'
import React, { useEffect, useLayoutEffect, useState } from 'react'
import { useTranslation } from 'react-i18next'
import {
    ActivityIndicator,
    Alert,
    Platform,
    StyleSheet,
    View
} from 'react-native'
import MapView, { PROVIDER_GOOGLE } from 'react-native-maps'
import {
    Text,
    TouchableRipple
} from 'react-native-paper'
import { IconSymbol } from '../../../components/ui/IconSymbol'
import { AddressSearchInput } from '../../components/maps/AddressSearchInput'
import { COLORS, GOOGLE_MAPS_CONFIG, isWithinServiceArea } from '../../utils/constants'

interface LocationData {
  latitude: number
  longitude: number
  address?: string
  city?: string
  district?: string
  place_id?: string
}

interface MapSelectionScreenParams {
  currentLocation?: LocationData | null
  onLocationSelect?: (location: LocationData) => void
}

type MapSelectionScreenNavigationProp = StackNavigationProp<any, 'MapSelection'>

export const MapSelectionScreen: React.FC = () => {
  const { t } = useTranslation()
  const navigation = useNavigation<MapSelectionScreenNavigationProp>()
  const route = useRoute()
  const params = route.params as MapSelectionScreenParams

  // Set initial location to default area if no current location provided
  const [location, setLocation] = useState<LocationData | null>(
    params?.currentLocation || {
      latitude: 35.3417, // Girne center
      longitude: 33.3242,
      address: 'Girne, KKTC',
      city: 'Girne',
      district: ''
    }
  )
  const [isLoadingLocation, setIsLoadingLocation] = useState(false)
  const [searchAddress, setSearchAddress] = useState('')
  const [isMapMoving, setIsMapMoving] = useState(false)
  const [debounceTimeout, setDebounceTimeout] = useState<NodeJS.Timeout | null>(null)
  const [hasInitialUserLocation, setHasInitialUserLocation] = useState(false)
  const [isInitialLocationSet, setIsInitialLocationSet] = useState(false)
  const [isMapReady, setIsMapReady] = useState(false)
  const [isLoadingInitialLocation, setIsLoadingInitialLocation] = useState(true)
  const mapRef = React.useRef<MapView>(null)

  // Set default location within service area (Girne center)
  const defaultLocation = {
    latitude: 35.3417, // Girne center
    longitude: 33.3242,
    latitudeDelta: 0.01,
    longitudeDelta: 0.01,
  }

  const [mapRegion, setMapRegion] = useState({
    latitude: params?.currentLocation?.latitude || defaultLocation.latitude,
    longitude: params?.currentLocation?.longitude || defaultLocation.longitude,
    latitudeDelta: defaultLocation.latitudeDelta,
    longitudeDelta: defaultLocation.longitudeDelta,
  })

  useLayoutEffect(() => {
    navigation.setOptions({
      title: t('checkout.selectLocation'),
      headerBackTitle: t('common.back'),
      headerStyle: {
        backgroundColor: COLORS.white,
        elevation: 0,
        shadowOpacity: 0,
      },
      headerTitleStyle: {
        color: COLORS.text,
        fontWeight: '600',
        fontSize: 18,
      },
      headerTintColor: COLORS.text,
      headerRight: () => location ? (
        <TouchableRipple 
          onPress={handleConfirmLocation}
          style={styles.headerConfirmButton}
        >
          <Text style={styles.headerConfirmText}>{t('common.confirm')}</Text>
        </TouchableRipple>
      ) : null,
    })
  }, [navigation, location, t])

  // Auto-get user location when screen loads (for login redirects)
  useEffect(() => {
    const autoGetUserLocation = async () => {
      // Always try to get user location first, regardless of params
      if (!hasInitialUserLocation) {
        setHasInitialUserLocation(true)
        setIsLoadingInitialLocation(true)
        
        // Get location first, then show map
        await getInitialLocation()
      }
    }

    autoGetUserLocation()
  }, [])

  // Function to get initial location before showing map
  const getInitialLocation = async () => {
    try {
      const { status } = await Location.requestForegroundPermissionsAsync()
      if (status !== 'granted') {
        // If permission denied, show map with default location
        setIsLoadingInitialLocation(false)
        setIsMapReady(true)
        return
      }

      let locationResult: any = null
      
      // Strategy 1: Try last known position first (instant)
      try {
        const lastKnown = await Location.getLastKnownPositionAsync({})
        if (lastKnown && lastKnown.coords) {
          console.log('âœ… Using last known position for initial load')
          locationResult = lastKnown
        }
      } catch (e) {
        console.log('âŒ Last known position failed:', e)
      }
      
      // Strategy 2: If no cached location, try fast GPS with timeout
      if (!locationResult) {
        const locationPromise = Location.getCurrentPositionAsync({
          accuracy: Location.Accuracy.Lowest,
        })
        
        const timeoutPromise = new Promise((_, reject) => 
          setTimeout(() => reject(new Error('Location timeout')), 4000) // 4 seconds for initial
        )
        
        try {
          locationResult = await Promise.race([locationPromise, timeoutPromise]) as any
          console.log('âœ… Got fresh GPS location for initial load')
        } catch (timeoutError) {
          console.log('âŒ GPS timeout for initial load, using default')
          // Use default location and show map
          setIsLoadingInitialLocation(false)
          setIsMapReady(true)
          return
        }
      }
      
      if (locationResult) {
        const { latitude, longitude } = locationResult.coords

        // Check if current location is within service area
        if (isWithinServiceArea(latitude, longitude)) {
          // Set location and map region before showing map
          setLocation({
            latitude,
            longitude,
            address: 'Konum alÄ±nÄ±yor...' // Temporary address
          })

          setMapRegion({
            latitude,
            longitude,
            latitudeDelta: 0.01,
            longitudeDelta: 0.01,
          })

          setIsInitialLocationSet(true)
          
          // Perform reverse geocoding to get address
          setTimeout(async () => {
            await performReverseGeocoding({ latitude, longitude })
          }, 500)
        }
      }
    } catch (error) {
      console.warn('Initial location detection failed:', error)
    } finally {
      setIsLoadingInitialLocation(false)
      setIsMapReady(true)
    }
  }

  // Cleanup timeouts on unmount
  useEffect(() => {
    return () => {
      if (debounceTimeout) {
        clearTimeout(debounceTimeout)
      }
    }
  }, [debounceTimeout])

  // Update location when map region changes (center pin effect) with debounce
  const handleRegionChangeComplete = async (region: any) => {
    setMapRegion(region)
    setIsMapMoving(false)

    // Clear existing timeout
    if (debounceTimeout) {
      clearTimeout(debounceTimeout)
    }

    // Check if center location is within service area
    if (!isWithinServiceArea(region.latitude, region.longitude)) {
      setLocation(null)
      return
    }

    // Don't do reverse geocoding if we're still loading initial location
    if (isLoadingLocation) {
      return
    }

    // Debounce reverse geocoding to avoid too many API calls
    // Wait 800ms after user stops moving map for better responsiveness
    const timeout = setTimeout(async () => {
      await performReverseGeocoding(region)
    }, 800)
    
    setDebounceTimeout(timeout)
  }

  // Separate function for reverse geocoding
  const performReverseGeocoding = async (region: any) => {

    try {
      // Add timeout for reverse geocoding to prevent hanging
      const reverseGeocodePromise = Location.reverseGeocodeAsync({
        latitude: region.latitude,
        longitude: region.longitude,
      })
      
      const timeoutPromise = new Promise((_, reject) => 
        setTimeout(() => reject(new Error('Reverse geocoding timeout')), 5000)
      )
      
      const addressResult = await Promise.race([reverseGeocodePromise, timeoutPromise]) as any

      let locationData: LocationData = {
        latitude: region.latitude,
        longitude: region.longitude,
      }

      if (addressResult && addressResult.length > 0) {
        const address = addressResult[0]
        
        // Simplified city detection - use API results first, fallback to coordinates
        let cityName = address.city || address.region || address.subregion
        
        // Simple coordinate-based fallback only for Cyprus region
        if (!cityName || cityName === 'Cyprus') {
          if (region.latitude >= 35.0 && region.latitude <= 35.7 && 
              region.longitude >= 32.0 && region.longitude <= 34.6) {
            // Determine city based on coordinates (simplified)
            if (region.latitude >= 35.3 && region.longitude >= 33.1 && region.longitude <= 33.5) {
              cityName = 'Girne'
            } else if (region.latitude >= 35.25 && region.longitude >= 33.5 && region.longitude <= 33.9) {
              cityName = 'Ä°skele' 
            } else if (region.latitude >= 35.0 && region.longitude >= 33.8 && region.longitude <= 34.1) {
              cityName = 'Magosa'
            } else {
              cityName = 'LefkoÅŸa'
            }
          } else {
            cityName = 'KKTC'
          }
        }
        
        // Get district
        let districtName = address.district || address.subregion || ''
        if (districtName === cityName) {
          districtName = ''
        }
        
        // Create address string
        const addressParts = []
        const street = address.street || address.name
        
        if (street && street !== cityName && street !== districtName) {
          addressParts.push(street)
        }
        if (districtName && districtName !== street) {
          addressParts.push(districtName)
        }
        if (cityName && cityName !== districtName) {
          addressParts.push(cityName)
        }
        
        locationData = {
          ...locationData,
          address: addressParts.join(', ') || t('checkout.noLocationInfo'),
          city: cityName,
          district: districtName
        }
      } else {
        locationData.address = t('checkout.noLocationInfo')
      }
      
      console.log('ðŸ“ Updated location in MapSelectionScreen:', locationData)
      setLocation(locationData)
    } catch (error) {
      console.warn('Reverse geocoding failed or timed out:', error)
      
      // Fallback: Create location with coordinates-based city
      let fallbackCity = 'KKTC'
      if (region.latitude >= 35.0 && region.latitude <= 35.7 && 
          region.longitude >= 32.0 && region.longitude <= 34.6) {
        if (region.latitude >= 35.3 && region.longitude >= 33.1 && region.longitude <= 33.5) {
          fallbackCity = 'Girne'
        } else if (region.latitude >= 35.25 && region.longitude >= 33.5 && region.longitude <= 33.9) {
          fallbackCity = 'Ä°skele' 
        } else if (region.latitude >= 35.0 && region.longitude >= 33.8 && region.longitude <= 34.1) {
          fallbackCity = 'Magosa'
        } else {
          fallbackCity = 'LefkoÅŸa'
        }
      }
      
      const fallbackLocation = {
        latitude: region.latitude,
        longitude: region.longitude,
        address: `${fallbackCity} bÃ¶lgesi`,
        city: fallbackCity,
        district: ''
      }
      
      console.log('ðŸ“ Fallback location in MapSelectionScreen:', fallbackLocation)
      setLocation(fallbackLocation)
    }
  }

  const handleRegionChange = () => {
    setIsMapMoving(true)
  }

  const handleConfirmLocation = () => {
    if (location && params?.onLocationSelect) {
      params.onLocationSelect(location)
    }
    
    // Always navigate to AddressEdit screen after location confirmation for checkout flow
    if (location) {
      navigation.navigate('AddressEdit', {
        location: location,
        userProfile: null, // Will be loaded in AddressEdit
        isFromCheckout: true, // Checkout akÄ±ÅŸÄ±ndan geldiÄŸini belirt
        onSave: (data: any) => {
          // Navigation AddressEdit'de yÃ¶netilir
          console.log('Address saved:', data)
        }
      })
    } else {
      navigation.goBack()
    }
  }

  const getCurrentLocation = async () => {
    setIsLoadingLocation(true)
    const { status } = await Location.requestForegroundPermissionsAsync()
    if (status !== 'granted') {
      Alert.alert(t('checkout.permissionRequired'), t('checkout.locationPermissionNeeded'))
      setIsLoadingLocation(false)
      return
    }
    
    try {
      // Try to get fresh location for manual button press
      const locationPromise = Location.getCurrentPositionAsync({
        accuracy: Location.Accuracy.Lowest,
      })
      
      const timeoutPromise = new Promise((_, reject) => 
        setTimeout(() => reject(new Error('Location timeout')), 8000) // 8 seconds for manual
      )
      
      const locationResult = await Promise.race([locationPromise, timeoutPromise]) as any
      console.log('âœ… Got manual location request')
      
      const { latitude, longitude } = locationResult.coords

      // Check if current location is within service area
      if (!isWithinServiceArea(latitude, longitude)) {
        Alert.alert(
          t('checkout.outsideServiceArea'),
          t('checkout.outsideServiceAreaMessage'),
          [{ text: t('common.ok') }]
        )
        setIsLoadingLocation(false)
        return
      }

      // Set location immediately with temporary address
      const tempLocation = {
        latitude,
        longitude,
        address: t('checkout.gettingLocation') // Temporary address while reverse geocoding
      }
      console.log('ðŸ“ Setting temporary location from getCurrentLocation:', tempLocation)
      setLocation(tempLocation)

      // Move map to current location smoothly
      const newRegion = {
        latitude,
        longitude,
        latitudeDelta: 0.01,
        longitudeDelta: 0.01,
      }
      
      setMapRegion(newRegion)
      
      // Use smooth animation if map ref is available
      if (mapRef.current) {
        mapRef.current.animateToRegion(newRegion, 1000)
      }

      // Get address
      setTimeout(async () => {
        await performReverseGeocoding({ latitude, longitude })
      }, 1000)

    } catch (error: any) {
      console.warn('Manual location detection failed:', error)
      
      Alert.alert(
        'Konum BulunamadÄ±',
        'GPS konumu bulunamadÄ±. HaritayÄ± hareket ettirerek konumunuzu seÃ§ebilirsiniz.',
        [
          { text: 'AnladÄ±m', style: 'default' },
          { text: 'Tekrar Dene', onPress: getCurrentLocation }
        ]
      )
    } finally {
      setIsLoadingLocation(false)
    }
  }

  const handleLocationSelect = (selectedLocation: LocationData) => {
    console.log('ðŸ“ Location selected from search:', selectedLocation)
    setLocation(selectedLocation)
    setSearchAddress(selectedLocation.address || '')
    
    // Mark that initial location is being set to prevent unwanted region changes
    setIsInitialLocationSet(false)
    
    // Move map to selected location smoothly
    const newRegion = {
      latitude: selectedLocation.latitude,
      longitude: selectedLocation.longitude,
      latitudeDelta: 0.01,
      longitudeDelta: 0.01,
    }
    
    setMapRegion(newRegion)
    
    // Use smooth animation if map ref is available
    if (mapRef.current) {
      mapRef.current.animateToRegion(newRegion, 1000)
    }

    // Allow region changes after a brief delay
    setTimeout(() => {
      setIsInitialLocationSet(true)
    }, 1500)
  }

  // Loading screen while getting initial location
  if (isLoadingInitialLocation) {
    return (
      <View style={styles.loadingContainer}>
        <View style={styles.loadingContent}>
          <ActivityIndicator size="large" color={COLORS.primary} />
          <Text style={styles.loadingTitle}>{t('checkout.gettingLocation') || 'Konumunuz AlÄ±nÄ±yor...'}</Text>
          <Text style={styles.loadingSubtitle}>{t('common.loading') || 'LÃ¼tfen bekleyin'}</Text>
        </View>
      </View>
    )
  }

  return (
    <View style={styles.container}>
      {/* Search Container */}
      <View style={styles.searchContainer}>
        {/* Service Area Info */}
        <View style={styles.serviceAreaInfo}>
          <IconSymbol name="mappin.circle" size={16} color={COLORS.primary} />
          <Text style={styles.serviceAreaText}>
            {t('checkout.serviceAreaInfo', { radius: GOOGLE_MAPS_CONFIG.SERVICE_AREA.radiusKm })}
          </Text>
        </View>

        {/* Professional Address Search Input */}
        <AddressSearchInput
          onLocationSelect={handleLocationSelect}
          placeholder={t('checkout.searchAddress')}
          value={searchAddress}
          onChangeText={setSearchAddress}
          style={styles.addressSearchInput}
        />

        {/* Find My Location Button */}
        <TouchableRipple 
          onPress={getCurrentLocation}
          disabled={isLoadingLocation}
          style={styles.locationButton}
        >
          <View style={styles.locationButtonContent}>
            {isLoadingLocation ? (
              <ActivityIndicator size="small" color={COLORS.primary} />
            ) : (
              <IconSymbol name="location.fill" size={16} color={COLORS.primary} />
            )}
            <Text style={styles.locationButtonText}>
              {isLoadingLocation ? t('checkout.gettingLocation') : t('checkout.findMyLocation')}
            </Text>
          </View>
        </TouchableRipple>
      </View>

      {/* Map Container */}
      <View style={styles.mapContainer}>
        <MapView
          ref={mapRef}
          style={styles.map}
          region={mapRegion}
          onRegionChange={handleRegionChange}
          onRegionChangeComplete={handleRegionChangeComplete}
          showsUserLocation={true}
          showsMyLocationButton={false}
          showsCompass={true}
          showsScale={false}
          showsTraffic={false}
          showsBuildings={true}
          showsIndoors={true}
          mapType="standard"
          scrollEnabled={true}
          zoomEnabled={true}
          rotateEnabled={true}
          pitchEnabled={true}
          provider={PROVIDER_GOOGLE}
        >
        </MapView>

        {/* Center Pin - Google Maps Style */}
        <View style={styles.centerPinContainer}>
          <View style={[
            styles.centerPin,
            isMapMoving && styles.centerPinMoving,
            !isWithinServiceArea(mapRegion.latitude, mapRegion.longitude) && styles.centerPinOutside
          ]}>
            <View style={styles.centerPinIcon}>
              <IconSymbol 
                name="location.fill" 
                size={20} 
                color={isWithinServiceArea(mapRegion.latitude, mapRegion.longitude) ? COLORS.white : COLORS.error} 
              />
            </View>
            <View style={[
              styles.centerPinTip,
              !isWithinServiceArea(mapRegion.latitude, mapRegion.longitude) && styles.centerPinTipOutside
            ]} />
          </View>
        </View>
        
        {isLoadingLocation && (
          <View style={styles.mapLoadingOverlay}>
            <View style={styles.mapLoadingContent}>
              <ActivityIndicator size="small" color={COLORS.primary} />
              <Text style={styles.mapLoadingText}>{t('checkout.gettingLocation')}</Text>
            </View>
          </View>
        )}
      </View>

      {/* Selected Location Footer */}
      {location && isWithinServiceArea(location.latitude, location.longitude) && (
        <View style={styles.locationFooter}>
          <View style={styles.locationDisplayHeader}>
            <IconSymbol name="checkmark.circle.fill" size={16} color={COLORS.success} />
            <Text style={styles.locationTitle}>{t('checkout.selectedLocation')}</Text>
          </View>
          <Text style={styles.locationText} numberOfLines={2}>
            {location.address || t('checkout.noLocationInfo')}
          </Text>
          <TouchableRipple 
            onPress={handleConfirmLocation}
            style={styles.confirmLocationButton}
          >
            <Text style={styles.confirmLocationButtonText}>{t('checkout.confirmLocation')}</Text>
          </TouchableRipple>
        </View>
      )}

      {/* Outside Service Area Warning */}
      {location && !isWithinServiceArea(location.latitude, location.longitude) && (
        <View style={styles.warningFooter}>
          <View style={styles.warningDisplayHeader}>
            <IconSymbol name="exclamationmark.triangle.fill" size={16} color={COLORS.warning} />
            <Text style={styles.warningTitle}>{t('checkout.outsideServiceArea')}</Text>
          </View>
          <Text style={styles.warningText}>
            {t('checkout.outsideServiceAreaMessage')}
          </Text>
        </View>
      )}
    </View>
  )
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: COLORS.background,
  },
  loadingContainer: {
    flex: 1,
    backgroundColor: COLORS.background,
    justifyContent: 'center',
    alignItems: 'center',
  },
  loadingContent: {
    alignItems: 'center',
    padding: 40,
  },
  loadingTitle: {
    fontSize: 18,
    fontWeight: '600',
    color: COLORS.text,
    marginTop: 20,
    textAlign: 'center',
  },
  loadingSubtitle: {
    fontSize: 14,
    color: COLORS.textSecondary,
    marginTop: 8,
    textAlign: 'center',
  },
  searchContainer: {
    padding: 20,
    backgroundColor: COLORS.white,
    borderBottomWidth: 1,
    borderBottomColor: COLORS.border,
  },
  serviceAreaInfo: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: COLORS.primary + '10',
    paddingHorizontal: 12,
    paddingVertical: 8,
    borderRadius: 8,
    marginBottom: 12,
  },
  serviceAreaText: {
    fontSize: 12,
    color: COLORS.primary,
    fontWeight: '500',
    marginLeft: 6,
  },
  addressSearchInput: {
    marginBottom: 12,
  },
  locationButton: {
    borderRadius: 50,
    backgroundColor: COLORS.background,
    borderWidth: 1,
    borderColor: COLORS.border,
  },
  locationButtonContent: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    paddingVertical: 10,
    paddingHorizontal: 16,
  },
  locationButtonText: {
    color: COLORS.primary,
    fontSize: 14,
    fontWeight: '500',
    marginLeft: 8,
  },
  mapContainer: {
    flex: 1,
    backgroundColor: COLORS.border + '10',
  },
  map: {
    width: '100%',
    height: '100%',
  },
  centerPinContainer: {
    position: 'absolute',
    top: '50%',
    left: '50%',
    justifyContent: 'center',
    alignItems: 'center',
    transform: [{ translateX: -20 }, { translateY: -40 }],
  },
  centerPin: {
    justifyContent: 'center',
    alignItems: 'center',
  },
  centerPinMoving: {
    transform: [{ translateY: -5 }],
  },
  centerPinOutside: {
    // Style for when outside service area
  },
  centerPinIcon: {
    width: 40,
    height: 40,
    borderRadius: 20,
    backgroundColor: COLORS.primary,
    justifyContent: 'center',
    alignItems: 'center',
    borderWidth: 3,
    borderColor: COLORS.white,
    shadowColor: COLORS.black,
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.3,
    shadowRadius: 4,
    elevation: 8,
  },
  centerPinTip: {
    width: 0,
    height: 0,
    borderLeftWidth: 8,
    borderRightWidth: 8,
    borderTopWidth: 12,
    borderLeftColor: 'transparent',
    borderRightColor: 'transparent',
    borderTopColor: COLORS.primary,
    marginTop: -1,
  },
  centerPinTipOutside: {
    borderTopColor: COLORS.error,
  },
  mapLoadingOverlay: {
    position: 'absolute',
    top: 0,
    left: 0,
    right: 0,
    bottom: 0,
    justifyContent: 'center',
    alignItems: 'center',
    backgroundColor: 'rgba(0,0,0,0.5)',
  },
  mapLoadingContent: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    padding: 10,
    backgroundColor: COLORS.white,
    borderRadius: 10,
  },
  mapLoadingText: {
    marginLeft: 8,
    fontSize: 14,
    color: COLORS.text,
  },
  locationFooter: {
    padding: 20,
    paddingBottom: Platform.OS === 'ios' ? 40 : 20,
    backgroundColor: COLORS.white,
    borderTopWidth: 1,
    borderTopColor: COLORS.border,
  },
  locationDisplayHeader: {
    flexDirection: 'row',
    alignItems: 'center',
    marginBottom: 4,
  },
  locationTitle: {
    fontSize: 14,
    fontWeight: '600',
    color: COLORS.text,
    marginLeft: 8,
  },
  locationText: {
    fontSize: 14,
    color: COLORS.textSecondary,
    marginBottom: 16,
    lineHeight: 20,
  },
  confirmLocationButton: {
    backgroundColor: COLORS.primary,
    borderRadius: 50,
    paddingVertical: 12,
    paddingHorizontal: 16,
    alignItems: 'center',
  },
  confirmLocationButtonText: {
    color: COLORS.white,
    fontSize: 16,
    fontWeight: '600',
  },
  warningFooter: {
    padding: 20,
    paddingBottom: Platform.OS === 'ios' ? 40 : 20,
    backgroundColor: COLORS.warning + '10',
    borderTopWidth: 1,
    borderTopColor: COLORS.warning + '30',
  },
  warningDisplayHeader: {
    flexDirection: 'row',
    alignItems: 'center',
    marginBottom: 4,
  },
  warningTitle: {
    fontSize: 14,
    fontWeight: '600',
    color: COLORS.warning,
    marginLeft: 8,
  },
  warningText: {
    fontSize: 14,
    color: COLORS.warning,
    lineHeight: 20,
  },
  headerConfirmButton: {
    paddingHorizontal: 16,
    paddingVertical: 8,
    borderRadius: 20,
    backgroundColor: COLORS.primary,
    marginRight: 16,
  },
  headerConfirmText: {
    color: COLORS.white,
    fontSize: 14,
    fontWeight: '600',
  },
}) 