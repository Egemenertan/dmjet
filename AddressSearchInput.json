import React, { useEffect, useRef, useState } from 'react'
import { useTranslation } from 'react-i18next'
import {
    ActivityIndicator,
    FlatList,
    Keyboard,
    StyleSheet,
    TextInput,
    TouchableOpacity,
    View,
} from 'react-native'
import { Text } from 'react-native-paper'
import { IconSymbol } from '../../../components/ui/IconSymbol'
import { COLORS, GOOGLE_MAPS_CONFIG, isWithinServiceArea } from '../../utils/constants'

interface PlaceResult {
  place_id: string
  description: string
  structured_formatting: {
    main_text: string
    secondary_text: string
  }
  types: string[]
}

interface LocationData {
  latitude: number
  longitude: number
  address: string
  city?: string
  district?: string
  place_id?: string
}

interface AddressSearchInputProps {
  onLocationSelect: (location: LocationData) => void
  placeholder?: string
  value?: string
  onChangeText?: (text: string) => void
  style?: any
}

const DEBOUNCE_DELAY = 300

export const AddressSearchInput: React.FC<AddressSearchInputProps> = ({
  onLocationSelect,
  placeholder,
  value: controlledValue,
  onChangeText,
  style
}) => {
  const { t } = useTranslation()
  const [searchText, setSearchText] = useState(controlledValue || '')
  const [predictions, setPredictions] = useState<PlaceResult[]>([])
  const [isLoading, setIsLoading] = useState(false)
  const [showSuggestions, setShowSuggestions] = useState(false)
  const [error, setError] = useState<string | null>(null)
  
  const debounceRef = useRef<ReturnType<typeof setTimeout> | null>(null)
  const inputRef = useRef<any>(null)

  // Google Places API base URL
  const PLACES_API_BASE = 'https://maps.googleapis.com/maps/api/place'
  const API_KEY = GOOGLE_MAPS_CONFIG.API_KEY

  useEffect(() => {
    if (controlledValue !== undefined) {
      setSearchText(controlledValue)
    }
  }, [controlledValue])

  const searchPlaces = async (query: string) => {
    if (!query.trim() || query.length < 3) {
      setPredictions([])
      setShowSuggestions(false)
      return
    }

    setIsLoading(true)
    setError(null)

    try {
      // Service area location and radius for better local results
      const serviceCenter = GOOGLE_MAPS_CONFIG.SERVICE_AREA.center
      const location = `${serviceCenter.latitude},${serviceCenter.longitude}`
      
      console.log('ðŸ” API Key:', API_KEY?.substring(0, 10) + '...')
      
      const autocompleteUrl = `${PLACES_API_BASE}/autocomplete/json?` +
        `input=${encodeURIComponent(query)}&` +
        `key=${API_KEY}&` +
        `location=${location}&` +
        `radius=${GOOGLE_MAPS_CONFIG.SERVICE_AREA.radiusMeters}&` +
        `strictbounds=true&` +
        `components=country:cy&` +
        `language=tr`

      console.log('ðŸŒ Request URL:', autocompleteUrl.replace(API_KEY, 'API_KEY_HIDDEN'))

      const response = await fetch(autocompleteUrl)
      const data = await response.json()

      console.log('ðŸ“± API Response:', data)

      if (data.status === 'OK' && data.predictions) {
        setPredictions(data.predictions.slice(0, 5)) // Limit to 5 results
        setShowSuggestions(true)
      } else if (data.status === 'ZERO_RESULTS') {
        setPredictions([])
        setShowSuggestions(false)
      } else {
        console.error('âŒ API Error:', data.status, data.error_message)
        throw new Error(data.error_message || `API Error: ${data.status}`)
      }
    } catch (error) {
      console.error('âŒ Places search error:', error)
      setError(t('checkout.searchLocationError'))
      setPredictions([])
      setShowSuggestions(false)
    } finally {
      setIsLoading(false)
    }
  }

  const getPlaceDetails = async (placeId: string) => {
    try {
      setIsLoading(true)
      
      const detailsUrl = `${PLACES_API_BASE}/details/json?` +
        `place_id=${placeId}&` +
        `key=${API_KEY}&` +
        `fields=geometry,formatted_address,address_components,name&` +
        `language=tr`

      const response = await fetch(detailsUrl)
      const data = await response.json()

      if (data.status === 'OK' && data.result) {
        const result = data.result
        const location = result.geometry.location

        // Check if location is within service area
        if (!isWithinServiceArea(location.lat, location.lng)) {
          setError(t('checkout.outsideServiceArea'))
          return
        }

        // Parse address components
        let city = ''
        let district = ''
        
        console.log('ðŸ” Google Places address components:', result.address_components)
        
        if (result.address_components) {
          result.address_components.forEach((component: any) => {
            const types = component.types
            
            // Try to get city from various component types
            if (types.includes('locality') || 
                types.includes('administrative_area_level_2') ||
                types.includes('sublocality_level_1')) {
              if (!city) city = component.long_name
            }
            
            // Try to get district from sublocality or administrative area
            if (types.includes('sublocality') || 
                types.includes('sublocality_level_2') ||
                types.includes('administrative_area_level_3')) {
              if (!district) district = component.long_name
            }
          })
        }
        
        // Coordinate-based city detection
        let coordinateBasedCity = null
        
        // Ä°skele bÃ¶lgesi (Girne'nin doÄŸusu, en Ã¶nce kontrol et)
        if (location.lat >= 35.25 && location.lat <= 35.4 && 
            location.lng >= 33.5 && location.lng <= 33.9) {
          coordinateBasedCity = 'Ä°skele'
          console.log(`ðŸ“ Google Places coordinates ${location.lat}, ${location.lng} â†’ Ä°skele`)
        }
        // Girne bÃ¶lgesi koordinatlarÄ± (kuzey batÄ± sahil)
        else if (location.lat >= 35.3 && location.lat <= 35.4 && 
                 location.lng >= 33.1 && location.lng <= 33.5) {
          coordinateBasedCity = 'Girne'
          console.log(`ðŸ“ Google Places coordinates ${location.lat}, ${location.lng} â†’ Girne`)
        }
        // LefkoÅŸa bÃ¶lgesi koordinatlarÄ± (merkez)
        else if (location.lat >= 35.1 && location.lat <= 35.3 && 
                 location.lng >= 33.2 && location.lng <= 33.6) {
          coordinateBasedCity = 'LefkoÅŸa'
          console.log(`ðŸ“ Google Places coordinates ${location.lat}, ${location.lng} â†’ LefkoÅŸa`)
        }
        // Magosa bÃ¶lgesi koordinatlarÄ± (doÄŸu sahil)
        else if (location.lat >= 35.0 && location.lat <= 35.3 && 
                 location.lng >= 33.8 && location.lng <= 34.1) {
          coordinateBasedCity = 'Magosa'
          console.log(`ðŸ“ Google Places coordinates ${location.lat}, ${location.lng} â†’ Magosa`)
        }
        
        // Check if city name looks like a village/technical name
        const isVillageName = city && (
          city.includes('tou') || 
          city.includes('Trikomou') ||
          city.length > 20 ||
          city.split(' ').length > 2
        )
        
        // Use coordinate-based city if no city, Cyprus, or village name
        if (!city || city === 'Cyprus' || isVillageName) {
          if (coordinateBasedCity) {
            console.log(`ðŸŽ¯ Google Places: Overriding "${city}" with coordinate-based city: ${coordinateBasedCity}`)
            city = coordinateBasedCity
          } else {
            city = 'KKTC' // Generic fallback
          }
        }
        
        console.log('ðŸ™ï¸ Google Places determined city:', city, 'district:', district)

        const locationData: LocationData = {
          latitude: location.lat,
          longitude: location.lng,
          address: result.formatted_address || result.name || '',
          city: city,
          district: district,
          place_id: placeId
        }

        onLocationSelect(locationData)
        setShowSuggestions(false)
        Keyboard.dismiss()
      } else {
        throw new Error(data.error_message || 'Place details failed')
      }
    } catch (error) {
      console.error('Place details error:', error)
      setError(t('checkout.locationError'))
    } finally {
      setIsLoading(false)
    }
  }

  const handleTextChange = (text: string) => {
    setSearchText(text)
    onChangeText?.(text)
    setError(null)

    // Clear previous debounce
    if (debounceRef.current) {
      clearTimeout(debounceRef.current)
    }

    // Debounce search
    debounceRef.current = setTimeout(() => {
      searchPlaces(text)
    }, DEBOUNCE_DELAY)
  }

  const handleSuggestionPress = (prediction: PlaceResult) => {
    setSearchText(prediction.description)
    onChangeText?.(prediction.description)
    getPlaceDetails(prediction.place_id)
  }

  const clearSearch = () => {
    setSearchText('')
    onChangeText?.('')
    setPredictions([])
    setShowSuggestions(false)
    setError(null)
    inputRef.current?.focus()
  }

  return (
    <View style={[styles.container, style]}>
      <TextInput
        ref={inputRef}
        placeholder={placeholder || t('checkout.searchAddress')}
        value={searchText}
        onChangeText={handleTextChange}
        style={[
          styles.input,
          showSuggestions && styles.inputFocused
        ]}
        placeholderTextColor={COLORS.textSecondary}
        onFocus={() => {
          if (predictions.length > 0) {
            setShowSuggestions(true)
          }
        }}
      />

      <View style={styles.rightIconContainer}>
        {searchText ? (
          isLoading ? (
            <ActivityIndicator size="small" color={COLORS.primary} />
          ) : (
            <TouchableOpacity onPress={clearSearch} activeOpacity={0.6}>
              <IconSymbol name="xmark" size={16} color={COLORS.textSecondary} />
            </TouchableOpacity>
          )
        ) : (
          <IconSymbol name="magnifyingglass" size={16} color={COLORS.textSecondary} />
        )}
      </View>

      {error && (
        <Text style={styles.errorText}>{error}</Text>
      )}

      {showSuggestions && predictions.length > 0 && (
        <View style={styles.suggestionsContainer}>
          <FlatList
            data={predictions}
            keyExtractor={(item) => item.place_id}
            renderItem={({ item, index }) => (
              <TouchableOpacity
                style={[
                  styles.suggestionItem,
                  index === predictions.length - 1 && styles.suggestionItemLast
                ]}
                onPress={() => handleSuggestionPress(item)}
                activeOpacity={0.7}
              >
                <View style={styles.suggestionIcon}>
                  <IconSymbol 
                    name={item.types.includes('establishment') ? 'building.2' : 'location'} 
                    size={14} 
                    color={COLORS.textSecondary} 
                  />
                </View>
                <View style={styles.suggestionText}>
                  <Text style={styles.suggestionMainText} numberOfLines={1}>
                    {item.structured_formatting.main_text}
                  </Text>
                  {item.structured_formatting.secondary_text && (
                    <Text style={styles.suggestionSecondaryText} numberOfLines={1}>
                      {item.structured_formatting.secondary_text}
                    </Text>
                  )}
                </View>
              </TouchableOpacity>
            )}
            style={styles.suggestionsList}
            keyboardShouldPersistTaps="handled"
            showsVerticalScrollIndicator={false}
          />
        </View>
      )}
    </View>
  )
}

const styles = StyleSheet.create({
  container: {
    position: 'relative',
    zIndex: 1000,
  },
  input: {
    backgroundColor: COLORS.white,
    borderRadius: 25,
    borderWidth: 1,
    borderColor: COLORS.border,
    height: 50,
    fontSize: 15,
    paddingHorizontal: 20,
    paddingRight: 50,
    color: COLORS.text,
  },
  inputFocused: {
    borderColor: COLORS.primary,
  },
  rightIconContainer: {
    position: 'absolute',
    right: 15,
    top: 15,
    width: 20,
    height: 20,
    justifyContent: 'center',
    alignItems: 'center',
  },
  errorText: {
    fontSize: 12,
    color: COLORS.error,
    marginTop: 6,
    marginLeft: 20,
  },
  suggestionsContainer: {
    position: 'absolute',
    top: '100%',
    left: 0,
    right: 0,
    backgroundColor: COLORS.white,
    borderRadius: 16,
    borderWidth: 1,
    borderColor: COLORS.border,
    marginTop: 8,
    maxHeight: 200,
    zIndex: 1001,
  },
  suggestionsList: {
    flexGrow: 0,
  },
  suggestionItem: {
    flexDirection: 'row',
    alignItems: 'center',
    paddingHorizontal: 20,
    paddingVertical: 14,
    borderBottomWidth: 1,
    borderBottomColor: COLORS.border + '20',
  },
  suggestionItemLast: {
    borderBottomWidth: 0,
  },
  suggestionIcon: {
    marginRight: 12,
    width: 20,
    alignItems: 'center',
  },
  suggestionText: {
    flex: 1,
  },
  suggestionMainText: {
    fontSize: 15,
    color: COLORS.text,
    fontWeight: '500',
  },
  suggestionSecondaryText: {
    fontSize: 13,
    color: COLORS.textSecondary,
    marginTop: 2,
  },
}) 